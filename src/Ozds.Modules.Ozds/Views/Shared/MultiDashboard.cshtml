@using Ozds.Elasticsearch
@using Ozds.Extensions

@model InitialQuery<MultiDashboardMeasurements>

@if (Model.Result.DeviceIds.EmptyEnumerable() ||
     Model.Result.Measurements.EmptyEnumerable())
{
  <span>
    @(T["No measurements available"].Value)
  </span>
  return;
}

<div class="d-flex flex-column mb-5" style="height: 400px;">
  <h5>
    @(T["Energy"].Value)
  </h5>
  <div class="d-flex flex-column flex-lg-row w-100 flex-grow-1">
    <div
        class="
          d-block justify-content-center
          position-relative flex-grow-1">
      <canvas id="energy-lines" />
    </div>
  </div>
</div>

<div class="d-flex flex-column mb-5" style="height: 400px;">
  <h5>
    @(T["Power"].Value)
  </h5>
  <div class="d-flex flex-column flex-lg-row w-100 flex-grow-1">
    <div
        class="
          d-block justify-content-center
          position-relative flex-grow-1">
      <canvas id="power-lines" />
    </div>
  </div>
</div>

<script at="Foot">
  // TODO: investigate null values here
  const createCharts = (multi, max, culture) => {
    const deviceIds = multi.deviceIds;
    const measurements = multi.measurements;
    const metadata = createMeasurementMetadata(multi, culture);

    return {
      energyLines: new Chart(
        "energy-lines",
        {
          type: "line",
          data: {
            labels: metadata.labels,
            datasets:
              deviceIds
                .map((deviceId, index) =>
                  ({
                    label: `@T["Energy of"].Value ${deviceId} (kW)`,
                    deviceId: deviceId,
                    data: measurements.map(measurementsByDevice =>
                      measurementsByDevice.data
                        .find(measurement => measurement.deviceId === deviceId)
                        ?.data?.energy),
                    borderColor: metadata.rainbow[index % rainbow.length],
                    backgroundColor: metadata.rainbow[index % rainbow.length],
                  })),
          },
          options: {
            maintainAspectRatio: false,
            plugins: {
              legend: true
            },
            scales: {
              x: {
                type: 'time',
                adapters: {
                  date: {
                    locale: culture,
                  },
                },
              },
            },
          },
        }),

      powerLines: new Chart(
        "power-lines",
        {
          type: "line",
          data: {
            labels: metadata.labels,
            datasets:
              deviceIds
                .map((deviceId, index) =>
                  ({
                    label: `@T["Power of"].Value ${deviceId} (kW)`,
                    data: measurements.map(measurementsByDevice =>
                      measurementsByDevice.data
                        .find(measurement =>
                          measurement.deviceId === deviceId)
                        ?.data?.power),
                    borderColor: metadata.rainbow[index % rainbow.length],
                    backgroundColor: metadata.rainbow[index % rainbow.length],
                  })),
          },
          options: {
            maintainAspectRatio: false,
            plugins: {
              legend: true
            },
            scales: {
              x: {
                type: 'time',
                adapters: {
                  date: {
                    locale: culture,
                  },
                },
              },
            },
          },
        }),
    };
  };

  const updateCharts = (multi, max, culture, charts) => {
    const measurements = multi.measurements;
    const metadata = createMeasurementMetadata(multi, culture);

    charts.energyLines.data.labels.push(...metadata.labels);
    charts.energyLines.data.datasets.forEach(dataset =>
      dataset.data.push(...measurements
        .map(measurementsByDevice => measurementsByDevice.data
          .find(measurement => measurement.deviceId === dataset.deviceId)
          ?.data?.energy)));

    charts.powerLines.data.labels.push(...metadata.labels);
    charts.powerLines.data.datasets.forEach(dataset =>
      dataset.data.push(...measurements
        .map(measurementsByDevice => measurementsByDevice.data
          .find(measurement => measurement.deviceId === dataset.deviceId)
          ?.data?.power)));

    charts.energyLines.update();
    charts.powerLines.update();
  };

  const createMeasurementMetadata = (multi, culture) => {
    return {
      labels: measurements.map(measurement => measurement.timestamp),
      rainbow: [ "Red", "Green", "Blue", "Cyan", "Yellow", "Magenta" ],
    }
  };

  const getMeasurements = async (model, period) =>
    period ?
      model.variables.ownerId ?
        await GraphQL
          .getDashboardMeasurementsByOwner(
            model.variables.ownerId,
            period)
      : model.variables.ownerUserId ?
        await GraphQL
          .getDashboardMeasurementsByOwnerUser(
            model.variables.ownerUserId,
            period)
      : null
    : GraphQL
        .normalizeMultiDashboardMeasurements(
          model.result);

  const updatePeriod = (model, period) =>
    period ?
      {
        from: period.to,
        to: luxon.DateTime.now()
      }
    : {
        from: GraphQL.deserializeDateTime(model.variables.period.to),
        to: luxon.DateTime.now()
      };

  const createOrUpdateCharts = (model, max, culture, charts) =>
    charts ? updateCharts(model, max, culture, charts)
    : createCharts(model, max, culture);

  const update = async ({model, max, culture, charts, period}) =>
    ({
      charts: createOrUpdateCharts(
        await getMeasurements(model, period),
        max,
        culture,
        charts),
      period: updatePeriod(model, period)
    });;

  window.onload = () => {
    const modelString = '@Html.Raw(Json.Serialize(Model))';
    const model = JSON.parse(modelString);

    const maxString = `{
      "power": @Dashboard.MaxPower,
      "current": @Dashboard.MaxCurrent,
      "voltage": @Dashboard.MaxVoltage
    }`;
    const max = JSON.parse(maxString);

    const culture = '@Html.Raw(Orchard.CultureName())';

    let period = null;
    let charts = null;
    const callback = async () => {
      const updated = await update({model, max, culture, charts, period});
      period = updated.period;
      charts = updated.charts;
    }

    callback();
    const interval = setInterval(callback, 10000);
    window.onunload = () => {
      clearInterval(interval);
    };
  };
</script>
<script asp-name="ozdstheme-luxon" at="Head"></script>
<script asp-name="ozdstheme-chart" at="Head"></script>
<script asp-name="ozdstheme-graphql" at="Head"></script>